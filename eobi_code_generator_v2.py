import sys

from torch import is_signed
import eobi_preprocessor_v2
import itertools
import re
import xml.etree.ElementTree as ET
from enum import IntEnum
import struct
# from dataclesses import dataclass, field, is_dataclass

def gen_header(o=sys.stdout):
	print('''\
import struct
from dataclasses import dataclass, field, is_dataclass
from enum import IntEnum
from scapy.all import *

# auto-generated by by eobi_code_generator.py
# code adapted from George Sauthoff with the following liscense info
# SPDX-FileCopyrightText: Â© 2021 Georg Sauthoff <mail@gms.tf>
# SPDX-License-Identifier: BSL-1.0
		''')

def gen_version(d, o=sys.stdout): # d -> data
	r = d.getroot()
	version = r.get('version')
	sub_version = r.get('subVersion')
	build = r.get('buildNumber')
	print(f"version = '{version}'", file=o)
	print(f"sub_version = '{sub_version}'", file=o)
	print(f"build = '{build}'\n", file=o)

# dt: data types dict
# ts: templates dict: numeric id -> message name
def gen_enums(dt, ts, o=sys.stdout):
	# populate no value
    def pp_nv(e, vs):  # e: all the attributes of the datatype vs: valid value obj associated with this e
        # noValue is how to represent the absence of the data
        nv = e.get('noValue')
        if nv in vs:  # if it's already in valid values
            return
        if nv.startswith('0x0'):  # if start with 0x0 this implies the rest is also 0
            nv = '0'
        if nv:  # otherwise append NO_VALUE to the enum class
            print(f'    NO_VALUE = {nv}', file=o)

	#generate template id enum
    print('class TemplateID(IntEnum):', file=o)
    for tid, name in ts:
        print(f'    {name} = {tid}', file=o)

    print('', file=o)
    for name, e in dt.items():
	# Here we only care about the cases where the data types has some valid values as
	# that is why we want to construct enum classes

	# when type of the data is int with valid value
        if e.get('type') == 'int':
            vs = e.findall('ValidValue')
            if vs:
				# sort the valid values
                vs.sort(key=lambda x: int(x.get('value')))

                ws = [v.get('value') for v in vs]  # possible values
                print(f'class {name}(IntEnum):', file=o)
                for v in vs:  # v here is a xml obj
                    print(
                    	f'    {v.get("name").upper()} = {v.get("value")}', file=o)
                pp_nv(e, ws)
                print(file=o)

		# string of len 1 with valid value
        elif e.get('rootType') == 'String' and e.get('size') == '1':
            vs = e.findall('ValidValue')
            if vs:
                vs.sort(key=lambda x: x.get('value'))
                ws = [v.get('value') for v in vs]
                print(f'class {name}(IntEnum):', file=o)
                for v in vs:
                    print(
                    	f'''    {v.get("name").upper()} = ord('{v.get("value")}')''', file=o)
                pp_nv(e, ws)
                print(file=o)


def get_sizes(st, dt):
    h = {}
	# datatype size
    for name, e in dt.items():
        v = e.get('size', '0')
        if e.get('variableSize') is None:
            h[name] = int(v)
        else:
            h[name] = 0

	#structure size
    for name, e in itertools.chain((i for i in st.items() if i[1].get('type') != 'Message'),  # i = (name, e)
                                   (i for i in st.items() if i[1].get('type') == 'Message')):
        s = 0  # total size
        for m in e: # for each member
            x = h.get(m.get('type'), 0)  # get size using type
            if x == 0 or m.get('minCardinality') is not None:
                s = 0
                break
            s += x
        h[name] = s
    return h


def get_max_sizes(st, dt):
    h = {}
    for name, e in dt.items():
        v = e.get('size', '0')
        h[name] = int(v)
    for name, e in itertools.chain((i for i in st.items() if i[1].get('type') != 'Message'),
                                   (i for i in st.items() if i[1].get('type') == 'Message')):
        s = 0
        for m in e:
            x = h.get(m.get('type'), 0)
            s += x * int(m.get('cardinality'))
        h[name] = s
    return h

def get_min_sizes(st, dt):
    h = {}
    for name, e in dt.items():
        v = e.get('size', '0')
        if e.get('variableSize') is None:
            h[name] = int(v)
        else:
            h[name] = 0
    for name, e in itertools.chain((i for i in st.items() if i[1].get('type') != 'Message'),
                                   (i for i in st.items() if i[1].get('type') == 'Message')):
        s = 0
        for m in e:
            x = h.get(m.get('type'), 0)
            s += x * int(m.get('minCardinality', '1'))
        h[name] = s
    return h

def pp_int_type(t):
	if not is_int(t):
		return None
	s = 'i'
	if is_unsigned(t):
		s = 'u'
	n = int(t.get('size'))
	s += str(n)
	return s 


def is_padding(t):
	pad_re = re.compile('Pad[1-9]')
	if t is not None:
		return t.get('rootType') == 'String' and pad_re.match(t.get('name'))
	return False

def is_int(t):
	if t is not None:
		r = t.get('rootType')
		return r in ('int', 'floatDecimal') or (r == 'String' and t.get('size') == '1')

def is_unsigned(t):
	v = t.get('minValue')
	return v is not None and not v.startswith('-')

def is_counter(t):
	return t.get('type') == 'Counter'

def is_enum(t):
	if t is not None:
		r = t.get('rootType')
		if r == 'int' or (r == 'String' and t.get('size') == '1'):
			return t.find('ValidValue') is not None
	return False


def is_fixed_string(t):
    if t is not None:
        return t.get('rootType') in ('String', 'data') and not t.get('variableSize')
    return False


def is_var_string(t):
    if t is not None:
        return t.get('rootType') in ('String', 'data') and t.get('variableSize') is not None
    return False

def is_component(t):
	if t is not None:
		return t.get('type') == 'Component'
	return False

def is_sequence(t):
	if t is not None:
		return t.get('type') == 'Sequence'
	return False

def gen_fields(e, st, dt, us, sizes, min_sizes, version, o=sys.stdout, comment=False, off=0, fname=None):
	print('    fields_desc = [', file=o)
	for m in e:
		if comment:
			print('	#', end='', file=o)
		atts = []
		t = dt.get(m.get('type'))
		if is_padding(t):
			print(f'''        StrLenField("{m.get('name')}", "{'0' * int(t.get('size'))}", {t.get('size')}),''', end='', file=o)
			print('', file=o)
		elif is_int(t):
			atts.append(pp_int_type(t))
			dft_str = '0'
			nv = t.get('noValue')
			# if nv:
			# 	dft_str = nv #TODO: this should be of higher priority
			# if dft_str == '0x00' or is_counter(t): # TODO: why is coutner important
			# 	dft_str = '0'
			# elif dft_str.startswith('0x80'): # TODO: perhaps not needed
			# 	dft_str = str(2**(8*int(t.get('size')) - 2) * -1)
			if is_enum(t):
				atts.append(f'enum:{t.get("name")}')
			scale = t.get('precision')
			if scale:
				atts.append(f'scale:{scale}')
			

			prefix = ''
			if not is_unsigned(t):
				prefix = 'Signed' 

			size = int(t.get('size'))
			
			if size == 1:
				print(f'''        ByteField("{m.get('name')}", {dft_str}),''', file=o)
			elif size == 2:
				print(f'''        LEShortField("{m.get('name')}", {dft_str}),''', file=o)
			elif size == 4:
				print(f'''        LE{prefix}IntField("{m.get('name')}", {dft_str}),''', file=o)
			elif size == 8:
				print(f'''        LE{prefix}LongField("{m.get('name')}", {dft_str}),''', file=o)
			else:
				print(f'''        Field {m.get('name')} Length Not Defined''')
				
		elif is_fixed_string(t) or is_var_string(t):
			dft_str = '0'
			nv = t.get('noValue')
			if nv:
				dft_str = nv
			# print(f'{m.attrib} 1',file=sys.stderr)
			if t.get('size') == None:
				print(f'{t.attrib} 1',file=sys.stderr)

			print(f'''        StrLenField("{m.get('name')}", {dft_str}, {t.get('size')}),''', file=o)
		else:
			t = st.get(m.get('type'))
			# print(t.get('type'), file=sys.stderr)
			if is_sequence(t):
				print(f'''        PacketListField("{m.get('name')}", None, {m.get('type')}),''', file=o)
			elif is_component(t):
				print(f'''        PacketField("{m.get('name')}", None, {m.get('type')}),''', file=o)
	print('    ]', file=o)	
	print('', file=o)

def gen_block(name, e, st, dt, us, sizes, min_sizes, max_sizes, version, o=sys.stdout):
	print(f'class {name}(Packet):', file=o)
	print(f"    name = '{name}'", file=o)
	print(f'	# sizes = ({min_sizes[name]}, {max_sizes[name]})\n', file=o)

	# generate all the fileds
	gen_fields(e, st, dt, us, sizes, min_sizes, version, o)

	if e.get('type') in ('Sequence', 'Component'):
		gen_extract_padding(o)


def gen_post_build(o):
	print('''
    def post_build(self, p, pay):
        # p += pay  # if you also want the payload to be taken into account
        if True:
            tmp_len = len(p) # edit as you want
            # p = p[:2] + struct.pack("<I", tmp_len) + p[4:]  # Adds length as short on bytes 3-4
            p = struct.pack("<H", tmp_len) + p[2:]
        return p + pay # edit if previous is changed
	''', file=o)

def gen_extract_padding(o):
	print('''
    def extract_padding(self, s):
        return '', s
	''', file=o)

# rule of thumb: when generating informations, generate for those that is of message type first, since
# messages are assembled using non message type
def gen_blocks(version, st, dt, us, o=sys.stdout):
    sizes = get_sizes(st, dt)
    min_sizes = get_min_sizes(st, dt)
    max_sizes = get_max_sizes(st, dt)
    for name, e in st.items():
        if e.get('type') == 'Message':
            continue
        gen_block(name, e, st, dt, us, sizes, min_sizes, max_sizes, version, o)
    for name, e in st.items():
        if e.get('type') != 'Message':
            continue
        gen_block(name, e, st, dt, us, sizes, min_sizes, max_sizes, version, o)
        gen_post_build(o)

def main():
	xml = ET.parse(eobi_preprocessor_v2.PATH_TO_SPEC)
	[dt, st, ts, us, mf] = eobi_preprocessor_v2.main()
	version = (xml.getroot().get('version'), xml.getroot().get('subVersion'))

	gen_header()
	gen_version(xml)
	gen_enums(dt, ts)
	gen_blocks(version, st, dt, us)

	# gen_message_flows(mf)

if __name__ == '__main__':
	sys.exit(main())
