import struct
from dataclasses import dataclass, field, is_dataclass
from enum import IntEnum
from scapy.all import *

# auto-generated by by eobi_code_generator.py
# code adapted from George Sauthoff with the following liscense info
# SPDX-FileCopyrightText: Â© 2021 Georg Sauthoff <mail@gms.tf>
# SPDX-License-Identifier: BSL-1.0
		
version = '10.0'
sub_version = 'None'
build = '101.3.19.ga-101004050-123'

class TemplateID(IntEnum):
    Heartbeat = 13001
    PacketHeader = 13005
    OrderAdd = 13100
    OrderModify = 13101
    OrderDelete = 13102
    OrderMassDelete = 13103
    FullOrderExecution = 13104
    PartialOrderExecution = 13105
    OrderModifySamePrio = 13106
    TradeReversal = 13200
    TradeReport = 13201
    ExecutionSummary = 13202
    ProductStateChange = 13300
    InstrumentStateChange = 13301
    MassInstrumentStateChange = 13302
    AddComplexInstrument = 13400
    AuctionBBO = 13500
    AuctionClearingPrice = 13501
    CrossRequest = 13502
    QuoteRequest = 13503
    TopOfBook = 13504
    ProductSummary = 13600
    InstrumentSummary = 13601
    SnapshotOrder = 13602

class AggressorSide(IntEnum):
    BUY = 1
    SELL = 2
    NO_VALUE = 0xFF

class AlgorithmicTradeIndicator(IntEnum):
    ALGORITHMICTRADE = 1
    NO_VALUE = 0xFF

class ApplSeqResetIndicator(IntEnum):
    NORESET = 0
    RESET = 1
    NO_VALUE = 0xFF

class BidOrdType(IntEnum):
    MARKET = 1
    NO_VALUE = 0xFF

class CompletionIndicator(IntEnum):
    INCOMPLETE = 0
    COMPLETE = 1
    NO_VALUE = 0xFF

class CrossRequestType(IntEnum):
    CROSSANNOUNCEMENT = 1
    LIQUIDITYIMPROVEMENTCROSS = 2
    NO_VALUE = 0xFF

class FastMarketIndicator(IntEnum):
    NO = 0
    YES = 1
    NO_VALUE = 0xFF

class ImpliedMarketIndicator(IntEnum):
    NOTIMPLIED = 0
    IMPLIEDINOUT = 3
    NO_VALUE = 0xFF

class InputSource(IntEnum):
    CLIPCLIENTBROKER = 1
    NO_VALUE = 0xFF

class InstrumentScopeProductComplex(IntEnum):
    SIMPLEINSTRUMENT = 1
    STANDARDOPTIONSTRATEGY = 2
    NONSTANDARDOPTIONSTRATEGY = 3
    VOLATILITYSTRATEGY = 4
    FUTURESSPREAD = 5
    INTERPRODUCTSPREAD = 6
    STANDARDFUTURESSTRATEGY = 7
    PACKANDBUNDLE = 8
    STRIP = 9
    NO_VALUE = 0xFF

class LastFragment(IntEnum):
    N = 0
    Y = 1
    NO_VALUE = 0xFF

class LegSecurityIDSource(IntEnum):
    MARKETPLACE = ord('M')
    NO_VALUE = 0

class LegSecurityType(IntEnum):
    LEGSECURITYMULTILEG = 1
    LEGSECURITYUNDERLYINGLEG = 2
    NO_VALUE = 0xFF

class LegSide(IntEnum):
    BUY = 1
    SELL = 2
    NO_VALUE = 0xFF

class MDEntryType(IntEnum):
    TRADE = 2
    OPENINGPRICE = 4
    CLOSINGPRICE = 5
    HIGHPRICE = 7
    LOWPRICE = 8
    TRADEVOLUME = 66
    PREVIOUSCLOSINGPRICE = 101
    OPENINGAUCTION = 200
    INTRADAYAUCTION = 201
    CIRCUITBREAKERAUCTION = 202
    CLOSINGAUCTION = 203
    IPOAUCTION = 204
    NO_VALUE = 0xFF

class MDReportEvent(IntEnum):
    SCOPEDEFINITION = 0
    NO_VALUE = 0xFF

class MDUpdateAction(IntEnum):
    NEW = 0
    CHANGE = 1
    DELETE = 2
    OVERLAY = 5
    NO_VALUE = 0xFF

class MarketCondition(IntEnum):
    NORMAL = 0
    STRESSED = 1
    NO_VALUE = 0xFF

class MarketDataType(IntEnum):
    ORDERBOOKMAINTENANCE = 1
    ORDERBOOKEXECUTION = 2
    TRADEREVERSAL = 3
    TRADEREPORT = 4
    AUCTIONBBO = 5
    AUCTIONCLEARINGPRICE = 6
    CROSSTRADEANNOUNCEMENT = 7
    QUOTEREQUEST = 8
    MARKETSEGMENTSNAPSHOT = 9
    SINGLEINSTRUMENTSNAPSHOT = 10
    ORDERBOOKSNAPSHOT = 11
    MATCHEVENT = 12
    TOPOFBOOK = 13
    NO_VALUE = 0xFF

class MassMarketCondition(IntEnum):
    NORMAL = 0
    STRESSED = 1
    NO_VALUE = 0xFF

class MassSoldOutIndicator(IntEnum):
    SOLDOUT = 1
    NO_VALUE = 0xFF

class MatchSubType(IntEnum):
    OPENINGAUCTION = 1
    CLOSINGAUCTION = 2
    INTRADAYAUCTION = 3
    CIRCUITBREAKERAUCTION = 4
    IPOAUCTION = 5
    NO_VALUE = 0xFF

class MatchType(IntEnum):
    CONFIRMEDTRADEREPORT = 3
    CROSSAUCTION = 5
    CALLAUCTION = 7
    LIQUIDITYIMPROVEMENTCROSS = 13
    CONTINUOUSAUCTION = 14
    NO_VALUE = 0xFF

class NoMarketSegments(IntEnum):
    ONE = 1
    NO_VALUE = 0xFF

class OfferOrdType(IntEnum):
    MARKET = 1
    NO_VALUE = 0xFF

class OrdType(IntEnum):
    MARKET = 1
    NO_VALUE = 0xFF

class PotentialSecurityTradingEvent(IntEnum):
    NONE = 0
    PRICEVOLATILITYAUCTIONISEXTENDED = 10
    NO_VALUE = 0xFF

class ProductComplex(IntEnum):
    SIMPLEINSTRUMENT = 1
    STANDARDOPTIONSTRATEGY = 2
    NONSTANDARDOPTIONSTRATEGY = 3
    VOLATILITYSTRATEGY = 4
    FUTURESSPREAD = 5
    INTERPRODUCTSPREAD = 6
    STANDARDFUTURESSTRATEGY = 7
    PACKANDBUNDLE = 8
    STRIP = 9
    NO_VALUE = 0xFF

class SecurityIDSource(IntEnum):
    MARKETPLACE = ord('M')
    NO_VALUE = 0

class SecurityMassStatus(IntEnum):
    ACTIVE = 1
    INACTIVE = 2
    EXPIRED = 4
    KNOCKEDOUT = 6
    KNOCKOUTREVOKED = 7
    SUSPENDED = 9
    PENDINGDELETION = 11
    KNOCKEDOUTANDSUSPENDED = 12
    NO_VALUE = 0xFF

class SecurityMassTradingEvent(IntEnum):
    PRICEVOLATILITYAUCTIONISEXTENDED = 10
    PRICEVOLATILITYAUCTIONISEXTENDEDAGAIN = 11
    NO_VALUE = 0xFF

class SecurityMassTradingStatus(IntEnum):
    TRADINGHALT = 2
    MARKETIMBALANCEBUY = 7
    MARKETIMBALANCESELL = 8
    CLOSED = 200
    RESTRICTED = 201
    BOOK = 202
    CONTINUOUS = 203
    OPENINGAUCTION = 204
    OPENINGAUCTIONFREEZE = 205
    INTRADAYAUCTION = 206
    INTRADAYAUCTIONFREEZE = 207
    CIRCUITBREAKERAUCTION = 208
    CIRCUITBREAKERAUCTIONFREEZE = 209
    CLOSINGAUCTION = 210
    CLOSINGAUCTIONFREEZE = 211
    IPOAUCTION = 212
    IPOAUCTIONFREEZE = 213
    PRECALL = 214
    CALL = 215
    FREEZE = 216
    TRADEATCLOSE = 217
    NO_VALUE = 0xFF

class SecurityStatus(IntEnum):
    ACTIVE = 1
    INACTIVE = 2
    EXPIRED = 4
    KNOCKEDOUT = 6
    KNOCKOUTREVOKED = 7
    SUSPENDED = 9
    PENDINGDELETION = 11
    KNOCKEDOUTANDSUSPENDED = 12
    NO_VALUE = 0xFF

class SecurityTradingEvent(IntEnum):
    PRICEVOLATILITYAUCTIONISEXTENDED = 10
    PRICEVOLATILITYAUCTIONISEXTENDEDAGAIN = 11
    NO_VALUE = 0xFF

class SecurityTradingStatus(IntEnum):
    TRADINGHALT = 2
    MARKETIMBALANCEBUY = 7
    MARKETIMBALANCESELL = 8
    CLOSED = 200
    RESTRICTED = 201
    BOOK = 202
    CONTINUOUS = 203
    OPENINGAUCTION = 204
    OPENINGAUCTIONFREEZE = 205
    INTRADAYAUCTION = 206
    INTRADAYAUCTIONFREEZE = 207
    CIRCUITBREAKERAUCTION = 208
    CIRCUITBREAKERAUCTIONFREEZE = 209
    CLOSINGAUCTION = 210
    CLOSINGAUCTIONFREEZE = 211
    IPOAUCTION = 212
    IPOAUCTIONFREEZE = 213
    PRECALL = 214
    CALL = 215
    FREEZE = 216
    TRADEATCLOSE = 217
    NO_VALUE = 0xFF

class SecurityUpdateAction(IntEnum):
    ADD = ord('A')
    NO_VALUE = 0

class Side(IntEnum):
    BUY = 1
    SELL = 2
    NO_VALUE = 0xFF

class SoldOutIndicator(IntEnum):
    SOLDOUT = 1
    NO_VALUE = 0xFF

class TradSesEvent(IntEnum):
    TBD = 0
    STATUSCHANGE = 3
    NO_VALUE = 0xFF

class TradSesStatus(IntEnum):
    HALTED = 1
    OPEN = 2
    CLOSED = 3
    NO_VALUE = 0xFF

class TradeCondition(IntEnum):
    IMPLIEDTRADE = 1
    OUTOFSEQUENCE = 107
    MIDPOINTPRICE = 155
    TRADINGONTERMSOFISSUE = 156
    SPECIALAUCTION = 596
    TRADEATCLOSE = 624
    NO_VALUE = 0xFFFF

class TradingSessionID(IntEnum):
    DAY = 1
    MORNING = 3
    EVENING = 5
    AFTERHOURS = 6
    HOLIDAY = 7
    NO_VALUE = 0xFF

class TradingSessionSubID(IntEnum):
    PRETRADING = 1
    CONTINUOUS = 3
    CLOSING = 4
    POSTTRADING = 5
    QUIESCENT = 7
    NO_VALUE = 0xFF

class InstrmtLegGrpComp(Packet):
    name = 'InstrmtLegGrpComp'
	# sizes = (32, 32)

    fields_desc = [
        LESignedIntField("LegSymbol", 0),
        StrFixedLenField("Pad4", "0000", 4),
        LESignedLongField("LegSecurityID", 0),
        LESignedLongField("LegPrice", 0),
        LESignedIntField("LegRatioQty", 0),
        ByteField("LegSecurityType", 0),
        ByteField("LegSide", 0),
        StrFixedLenField("Pad2", "00", 2),
    ]


    def extract_padding(self, s):
        return '', s
	
class MDInstrumentEntryGrpComp(Packet):
    name = 'MDInstrumentEntryGrpComp'
	# sizes = (24, 24)

    fields_desc = [
        LESignedLongField("MDEntryPx", 0),
        LESignedLongField("MDEntrySize", 0),
        ByteField("MDEntryType", 0),
        StrFixedLenField("Pad1", "0", 1),
        LEShortField("TradeCondition", 0),
        StrFixedLenField("Pad4", "0000", 4),
    ]


    def extract_padding(self, s):
        return '', s
	
class MDTradeEntryGrpComp(Packet):
    name = 'MDTradeEntryGrpComp'
	# sizes = (24, 24)

    fields_desc = [
        LESignedLongField("MDEntryPx", 0),
        LESignedLongField("MDEntrySize", 0),
        ByteField("MDEntryType", 0),
        StrFixedLenField("Pad7", "0000000", 7),
    ]


    def extract_padding(self, s):
        return '', s
	
class MessageHeaderComp(Packet):
    name = 'MessageHeaderComp'
	# sizes = (8, 8)

    fields_desc = [
        LEShortField("BodyLen", 0),
        LEShortField("TemplateID", 0),
        LEIntField("MsgSeqNum", 0),
    ]


    def extract_padding(self, s):
        return '', s
	
class OrderDetailsComp(Packet):
    name = 'OrderDetailsComp'
	# sizes = (32, 32)

    fields_desc = [
        LELongField("TrdRegTSTimePriority", 0),
        LESignedLongField("DisplayQty", 0),
        ByteField("Side", 0),
        ByteField("OrdType", 0),
        StrFixedLenField("Pad6", "000000", 6),
        LESignedLongField("Price", 0),
    ]


    def extract_padding(self, s):
        return '', s
	
class SecMassStatGrpComp(Packet):
    name = 'SecMassStatGrpComp'
	# sizes = (32, 32)

    fields_desc = [
        LESignedLongField("SecurityID", 0),
        LESignedLongField("HighPx", 0),
        LESignedLongField("LowPx", 0),
        ByteField("SecurityStatus", 0),
        ByteField("SecurityTradingStatus", 0),
        ByteField("MarketCondition", 0),
        ByteField("SecurityTradingEvent", 0),
        ByteField("SoldOutIndicator", 0),
        StrFixedLenField("Pad3", "000", 3),
    ]


    def extract_padding(self, s):
        return '', s
	
class AddComplexInstrument(Packet):
    name = 'AddComplexInstrument'
	# sizes = (104, 680)

    fields_desc = [
        PacketField("MessageHeader", None, MessageHeaderComp),
        LESignedLongField("SecurityID", 0),
        LELongField("TransactTime", 0),
        LESignedIntField("SecuritySubType", 0),
        ByteField("ProductComplex", 0),
        ByteField("ImpliedMarketIndicator", 0),
        StrFixedLenField("Pad2", "00", 2),
        LEIntField("LegRatioMultiplier", 0),
        ByteField("NoLegs", 0),
        StrFixedLenField("Pad3", "000", 3),
        PacketListField("InstrmtLegGrp", None, InstrmtLegGrpComp),
    ]


    def post_build(self, p, pay):
        # p += pay  # if you also want the payload to be taken into account
        if True:
            tmp_len = len(p) # edit as you want
            # p = p[:2] + struct.pack("<I", tmp_len) + p[4:]  # Adds length as short on bytes 3-4
            p = struct.pack("<H", tmp_len) + p[2:]
        return p + pay # edit if previous is changed
	
class AuctionBBO(Packet):
    name = 'AuctionBBO'
	# sizes = (64, 64)

    fields_desc = [
        PacketField("MessageHeader", None, MessageHeaderComp),
        LELongField("TransactTime", 0),
        LESignedLongField("SecurityID", 0),
        LESignedLongField("BidPx", 0),
        LESignedLongField("OfferPx", 0),
        LESignedLongField("BidSize", 0),
        LESignedLongField("OfferSize", 0),
        ByteField("PotentialSecurityTradingEvent", 0),
        ByteField("BidOrdType", 0),
        ByteField("OfferOrdType", 0),
        StrFixedLenField("Pad5", "00000", 5),
    ]


    def post_build(self, p, pay):
        # p += pay  # if you also want the payload to be taken into account
        if True:
            tmp_len = len(p) # edit as you want
            # p = p[:2] + struct.pack("<I", tmp_len) + p[4:]  # Adds length as short on bytes 3-4
            p = struct.pack("<H", tmp_len) + p[2:]
        return p + pay # edit if previous is changed
	
class AuctionClearingPrice(Packet):
    name = 'AuctionClearingPrice'
	# sizes = (56, 56)

    fields_desc = [
        PacketField("MessageHeader", None, MessageHeaderComp),
        LELongField("TransactTime", 0),
        LESignedLongField("SecurityID", 0),
        LESignedLongField("LastPx", 0),
        LESignedLongField("LastQty", 0),
        LESignedLongField("ImbalanceQty", 0),
        ByteField("SecurityTradingStatus", 0),
        ByteField("PotentialSecurityTradingEvent", 0),
        StrFixedLenField("Pad6", "000000", 6),
    ]


    def post_build(self, p, pay):
        # p += pay  # if you also want the payload to be taken into account
        if True:
            tmp_len = len(p) # edit as you want
            # p = p[:2] + struct.pack("<I", tmp_len) + p[4:]  # Adds length as short on bytes 3-4
            p = struct.pack("<H", tmp_len) + p[2:]
        return p + pay # edit if previous is changed
	
class CrossRequest(Packet):
    name = 'CrossRequest'
	# sizes = (48, 48)

    fields_desc = [
        PacketField("MessageHeader", None, MessageHeaderComp),
        LESignedLongField("SecurityID", 0),
        LESignedLongField("LastPx", 0),
        LESignedLongField("LastQty", 0),
        ByteField("Side", 0),
        ByteField("CrossRequestType", 0),
        ByteField("InputSource", 0),
        StrFixedLenField("Pad5", "00000", 5),
        LELongField("TransactTime", 0),
    ]


    def post_build(self, p, pay):
        # p += pay  # if you also want the payload to be taken into account
        if True:
            tmp_len = len(p) # edit as you want
            # p = p[:2] + struct.pack("<I", tmp_len) + p[4:]  # Adds length as short on bytes 3-4
            p = struct.pack("<H", tmp_len) + p[2:]
        return p + pay # edit if previous is changed
	
class ExecutionSummary(Packet):
    name = 'ExecutionSummary'
	# sizes = (80, 80)

    fields_desc = [
        PacketField("MessageHeader", None, MessageHeaderComp),
        LESignedLongField("SecurityID", 0),
        LELongField("AggressorTime", 0),
        LELongField("RequestTime", 0),
        LELongField("ExecID", 0),
        LESignedLongField("LastQty", 0),
        ByteField("AggressorSide", 0),
        StrFixedLenField("Pad1", "0", 1),
        LEShortField("TradeCondition", 0),
        StrFixedLenField("Pad4", "0000", 4),
        LESignedLongField("LastPx", 0),
        LESignedLongField("RestingHiddenQty", 0),
        LESignedLongField("RestingCxlQty", 0),
    ]


    def post_build(self, p, pay):
        # p += pay  # if you also want the payload to be taken into account
        if True:
            tmp_len = len(p) # edit as you want
            # p = p[:2] + struct.pack("<I", tmp_len) + p[4:]  # Adds length as short on bytes 3-4
            p = struct.pack("<H", tmp_len) + p[2:]
        return p + pay # edit if previous is changed
	
class FullOrderExecution(Packet):
    name = 'FullOrderExecution'
	# sizes = (56, 56)

    fields_desc = [
        PacketField("MessageHeader", None, MessageHeaderComp),
        ByteField("Side", 0),
        ByteField("OrdType", 0),
        ByteField("AlgorithmicTradeIndicator", 0),
        StrFixedLenField("Pad1", "0", 1),
        LEIntField("TrdMatchID", 0),
        LESignedLongField("Price", 0),
        LELongField("TrdRegTSTimePriority", 0),
        LESignedLongField("SecurityID", 0),
        LESignedLongField("LastQty", 0),
        LESignedLongField("LastPx", 0),
    ]


    def post_build(self, p, pay):
        # p += pay  # if you also want the payload to be taken into account
        if True:
            tmp_len = len(p) # edit as you want
            # p = p[:2] + struct.pack("<I", tmp_len) + p[4:]  # Adds length as short on bytes 3-4
            p = struct.pack("<H", tmp_len) + p[2:]
        return p + pay # edit if previous is changed
	
class Heartbeat(Packet):
    name = 'Heartbeat'
	# sizes = (16, 16)

    fields_desc = [
        PacketField("MessageHeader", None, MessageHeaderComp),
        LEIntField("LastMsgSeqNumProcessed", 0),
        StrFixedLenField("Pad4", "0000", 4),
    ]


    def post_build(self, p, pay):
        # p += pay  # if you also want the payload to be taken into account
        if True:
            tmp_len = len(p) # edit as you want
            # p = p[:2] + struct.pack("<I", tmp_len) + p[4:]  # Adds length as short on bytes 3-4
            p = struct.pack("<H", tmp_len) + p[2:]
        return p + pay # edit if previous is changed
	
class InstrumentStateChange(Packet):
    name = 'InstrumentStateChange'
	# sizes = (48, 48)

    fields_desc = [
        PacketField("MessageHeader", None, MessageHeaderComp),
        LESignedLongField("SecurityID", 0),
        ByteField("SecurityStatus", 0),
        ByteField("SecurityTradingStatus", 0),
        ByteField("MarketCondition", 0),
        ByteField("FastMarketIndicator", 0),
        ByteField("SecurityTradingEvent", 0),
        ByteField("SoldOutIndicator", 0),
        StrFixedLenField("Pad2", "00", 2),
        LESignedLongField("HighPx", 0),
        LESignedLongField("LowPx", 0),
        LELongField("TransactTime", 0),
    ]


    def post_build(self, p, pay):
        # p += pay  # if you also want the payload to be taken into account
        if True:
            tmp_len = len(p) # edit as you want
            # p = p[:2] + struct.pack("<I", tmp_len) + p[4:]  # Adds length as short on bytes 3-4
            p = struct.pack("<H", tmp_len) + p[2:]
        return p + pay # edit if previous is changed
	
class InstrumentSummary(Packet):
    name = 'InstrumentSummary'
	# sizes = (64, 424)

    fields_desc = [
        PacketField("MessageHeader", None, MessageHeaderComp),
        LESignedLongField("SecurityID", 0),
        LELongField("LastUpdateTime", 0),
        LELongField("TrdRegTSExecutionTime", 0),
        LEShortField("TotNoOrders", 0),
        ByteField("SecurityStatus", 0),
        ByteField("SecurityTradingStatus", 0),
        ByteField("MarketCondition", 0),
        ByteField("FastMarketIndicator", 0),
        ByteField("SecurityTradingEvent", 0),
        ByteField("SoldOutIndicator", 0),
        LESignedLongField("HighPx", 0),
        LESignedLongField("LowPx", 0),
        ByteField("ProductComplex", 0),
        ByteField("NoMDEntries", 0),
        StrFixedLenField("Pad6", "000000", 6),
        PacketListField("MDInstrumentEntryGrp", None, MDInstrumentEntryGrpComp),
    ]


    def post_build(self, p, pay):
        # p += pay  # if you also want the payload to be taken into account
        if True:
            tmp_len = len(p) # edit as you want
            # p = p[:2] + struct.pack("<I", tmp_len) + p[4:]  # Adds length as short on bytes 3-4
            p = struct.pack("<H", tmp_len) + p[2:]
        return p + pay # edit if previous is changed
	
class MassInstrumentStateChange(Packet):
    name = 'MassInstrumentStateChange'
	# sizes = (32, 800)

    fields_desc = [
        PacketField("MessageHeader", None, MessageHeaderComp),
        ByteField("InstrumentScopeProductComplex", 0),
        ByteField("SecurityMassStatus", 0),
        ByteField("SecurityMassTradingStatus", 0),
        ByteField("MassMarketCondition", 0),
        ByteField("FastMarketIndicator", 0),
        ByteField("SecurityMassTradingEvent", 0),
        ByteField("MassSoldOutIndicator", 0),
        StrFixedLenField("Pad1", "0", 1),
        LELongField("TransactTime", 0),
        ByteField("LastFragment", 0),
        ByteField("NoRelatedSym", 0),
        StrFixedLenField("Pad6", "000000", 6),
        PacketListField("SecMassStatGrp", None, SecMassStatGrpComp),
    ]


    def post_build(self, p, pay):
        # p += pay  # if you also want the payload to be taken into account
        if True:
            tmp_len = len(p) # edit as you want
            # p = p[:2] + struct.pack("<I", tmp_len) + p[4:]  # Adds length as short on bytes 3-4
            p = struct.pack("<H", tmp_len) + p[2:]
        return p + pay # edit if previous is changed
	
class OrderAdd(Packet):
    name = 'OrderAdd'
	# sizes = (56, 56)

    fields_desc = [
        PacketField("MessageHeader", None, MessageHeaderComp),
        LELongField("TrdRegTSTimeIn", 0),
        LESignedLongField("SecurityID", 0),
        PacketField("OrderDetails", None, OrderDetailsComp),
    ]


    def post_build(self, p, pay):
        # p += pay  # if you also want the payload to be taken into account
        if True:
            tmp_len = len(p) # edit as you want
            # p = p[:2] + struct.pack("<I", tmp_len) + p[4:]  # Adds length as short on bytes 3-4
            p = struct.pack("<H", tmp_len) + p[2:]
        return p + pay # edit if previous is changed
	
class OrderDelete(Packet):
    name = 'OrderDelete'
	# sizes = (64, 64)

    fields_desc = [
        PacketField("MessageHeader", None, MessageHeaderComp),
        LELongField("TrdRegTSTimeIn", 0),
        LELongField("TransactTime", 0),
        LESignedLongField("SecurityID", 0),
        PacketField("OrderDetails", None, OrderDetailsComp),
    ]


    def post_build(self, p, pay):
        # p += pay  # if you also want the payload to be taken into account
        if True:
            tmp_len = len(p) # edit as you want
            # p = p[:2] + struct.pack("<I", tmp_len) + p[4:]  # Adds length as short on bytes 3-4
            p = struct.pack("<H", tmp_len) + p[2:]
        return p + pay # edit if previous is changed
	
class OrderMassDelete(Packet):
    name = 'OrderMassDelete'
	# sizes = (24, 24)

    fields_desc = [
        PacketField("MessageHeader", None, MessageHeaderComp),
        LESignedLongField("SecurityID", 0),
        LELongField("TransactTime", 0),
    ]


    def post_build(self, p, pay):
        # p += pay  # if you also want the payload to be taken into account
        if True:
            tmp_len = len(p) # edit as you want
            # p = p[:2] + struct.pack("<I", tmp_len) + p[4:]  # Adds length as short on bytes 3-4
            p = struct.pack("<H", tmp_len) + p[2:]
        return p + pay # edit if previous is changed
	
class OrderModify(Packet):
    name = 'OrderModify'
	# sizes = (80, 80)

    fields_desc = [
        PacketField("MessageHeader", None, MessageHeaderComp),
        LELongField("TrdRegTSTimeIn", 0),
        LELongField("TrdRegTSPrevTimePriority", 0),
        LESignedLongField("PrevPrice", 0),
        LESignedLongField("PrevDisplayQty", 0),
        LESignedLongField("SecurityID", 0),
        PacketField("OrderDetails", None, OrderDetailsComp),
    ]


    def post_build(self, p, pay):
        # p += pay  # if you also want the payload to be taken into account
        if True:
            tmp_len = len(p) # edit as you want
            # p = p[:2] + struct.pack("<I", tmp_len) + p[4:]  # Adds length as short on bytes 3-4
            p = struct.pack("<H", tmp_len) + p[2:]
        return p + pay # edit if previous is changed
	
class OrderModifySamePrio(Packet):
    name = 'OrderModifySamePrio'
	# sizes = (72, 72)

    fields_desc = [
        PacketField("MessageHeader", None, MessageHeaderComp),
        LELongField("TrdRegTSTimeIn", 0),
        LELongField("TransactTime", 0),
        LESignedLongField("PrevDisplayQty", 0),
        LESignedLongField("SecurityID", 0),
        PacketField("OrderDetails", None, OrderDetailsComp),
    ]


    def post_build(self, p, pay):
        # p += pay  # if you also want the payload to be taken into account
        if True:
            tmp_len = len(p) # edit as you want
            # p = p[:2] + struct.pack("<I", tmp_len) + p[4:]  # Adds length as short on bytes 3-4
            p = struct.pack("<H", tmp_len) + p[2:]
        return p + pay # edit if previous is changed
	
class PacketHeader(Packet):
    name = 'PacketHeader'
	# sizes = (32, 32)

    fields_desc = [
        PacketField("MessageHeader", None, MessageHeaderComp),
        LEIntField("ApplSeqNum", 0),
        LESignedIntField("MarketSegmentID", 0),
        ByteField("PartitionID", 0),
        ByteField("CompletionIndicator", 0),
        ByteField("ApplSeqResetIndicator", 0),
        ByteField("DSCP", 0),
        StrFixedLenField("Pad4", "0000", 4),
        LELongField("TransactTime", 0),
    ]

    def guess_payload_class(self, payload):
        t = struct.unpack('<h', payload[2:4])[0]
        if t == 13001: return Heartbeat
        if t == 13005: return PacketHeader
        if t == 13100: return OrderAdd
        if t == 13101: return OrderModify
        if t == 13102: return OrderDelete
        if t == 13103: return OrderMassDelete
        if t == 13104: return FullOrderExecution
        if t == 13105: return PartialOrderExecution
        if t == 13106: return OrderModifySamePrio
        if t == 13200: return TradeReversal
        if t == 13201: return TradeReport
        if t == 13202: return ExecutionSummary
        if t == 13300: return ProductStateChange
        if t == 13301: return InstrumentStateChange
        if t == 13302: return MassInstrumentStateChange
        if t == 13400: return AddComplexInstrument
        if t == 13500: return AuctionBBO
        if t == 13501: return AuctionClearingPrice
        if t == 13502: return CrossRequest
        if t == 13503: return QuoteRequest
        if t == 13504: return TopOfBook
        if t == 13600: return ProductSummary
        if t == 13601: return InstrumentSummary
        if t == 13602: return SnapshotOrder
        else: return Packet.guess_payload_class(self, payload)

    def post_build(self, p, pay):
        # p += pay  # if you also want the payload to be taken into account
        if True:
            tmp_len = len(p) # edit as you want
            # p = p[:2] + struct.pack("<I", tmp_len) + p[4:]  # Adds length as short on bytes 3-4
            p = struct.pack("<H", tmp_len) + p[2:]
        return p + pay # edit if previous is changed
	
class PartialOrderExecution(Packet):
    name = 'PartialOrderExecution'
	# sizes = (56, 56)

    fields_desc = [
        PacketField("MessageHeader", None, MessageHeaderComp),
        ByteField("Side", 0),
        ByteField("OrdType", 0),
        ByteField("AlgorithmicTradeIndicator", 0),
        StrFixedLenField("Pad1", "0", 1),
        LEIntField("TrdMatchID", 0),
        LESignedLongField("Price", 0),
        LELongField("TrdRegTSTimePriority", 0),
        LESignedLongField("SecurityID", 0),
        LESignedLongField("LastQty", 0),
        LESignedLongField("LastPx", 0),
    ]


    def post_build(self, p, pay):
        # p += pay  # if you also want the payload to be taken into account
        if True:
            tmp_len = len(p) # edit as you want
            # p = p[:2] + struct.pack("<I", tmp_len) + p[4:]  # Adds length as short on bytes 3-4
            p = struct.pack("<H", tmp_len) + p[2:]
        return p + pay # edit if previous is changed
	
class ProductStateChange(Packet):
    name = 'ProductStateChange'
	# sizes = (24, 24)

    fields_desc = [
        PacketField("MessageHeader", None, MessageHeaderComp),
        ByteField("TradingSessionID", 0),
        ByteField("TradingSessionSubID", 0),
        ByteField("TradSesStatus", 0),
        ByteField("MarketCondition", 0),
        ByteField("FastMarketIndicator", 0),
        StrFixedLenField("Pad3", "000", 3),
        LELongField("TransactTime", 0),
    ]


    def post_build(self, p, pay):
        # p += pay  # if you also want the payload to be taken into account
        if True:
            tmp_len = len(p) # edit as you want
            # p = p[:2] + struct.pack("<I", tmp_len) + p[4:]  # Adds length as short on bytes 3-4
            p = struct.pack("<H", tmp_len) + p[2:]
        return p + pay # edit if previous is changed
	
class ProductSummary(Packet):
    name = 'ProductSummary'
	# sizes = (24, 24)

    fields_desc = [
        PacketField("MessageHeader", None, MessageHeaderComp),
        LEIntField("LastMsgSeqNumProcessed", 0),
        ByteField("TradingSessionID", 0),
        ByteField("TradingSessionSubID", 0),
        ByteField("TradSesStatus", 0),
        ByteField("MarketCondition", 0),
        ByteField("FastMarketIndicator", 0),
        StrFixedLenField("Pad7", "0000000", 7),
    ]


    def post_build(self, p, pay):
        # p += pay  # if you also want the payload to be taken into account
        if True:
            tmp_len = len(p) # edit as you want
            # p = p[:2] + struct.pack("<I", tmp_len) + p[4:]  # Adds length as short on bytes 3-4
            p = struct.pack("<H", tmp_len) + p[2:]
        return p + pay # edit if previous is changed
	
class QuoteRequest(Packet):
    name = 'QuoteRequest'
	# sizes = (40, 40)

    fields_desc = [
        PacketField("MessageHeader", None, MessageHeaderComp),
        LESignedLongField("SecurityID", 0),
        LESignedLongField("LastQty", 0),
        ByteField("Side", 0),
        StrFixedLenField("Pad7", "0000000", 7),
        LELongField("TransactTime", 0),
    ]


    def post_build(self, p, pay):
        # p += pay  # if you also want the payload to be taken into account
        if True:
            tmp_len = len(p) # edit as you want
            # p = p[:2] + struct.pack("<I", tmp_len) + p[4:]  # Adds length as short on bytes 3-4
            p = struct.pack("<H", tmp_len) + p[2:]
        return p + pay # edit if previous is changed
	
class SnapshotOrder(Packet):
    name = 'SnapshotOrder'
	# sizes = (40, 40)

    fields_desc = [
        PacketField("MessageHeader", None, MessageHeaderComp),
        PacketField("OrderDetails", None, OrderDetailsComp),
    ]


    def post_build(self, p, pay):
        # p += pay  # if you also want the payload to be taken into account
        if True:
            tmp_len = len(p) # edit as you want
            # p = p[:2] + struct.pack("<I", tmp_len) + p[4:]  # Adds length as short on bytes 3-4
            p = struct.pack("<H", tmp_len) + p[2:]
        return p + pay # edit if previous is changed
	
class TopOfBook(Packet):
    name = 'TopOfBook'
	# sizes = (64, 64)

    fields_desc = [
        PacketField("MessageHeader", None, MessageHeaderComp),
        LELongField("TransactTime", 0),
        LESignedLongField("SecurityID", 0),
        LESignedLongField("BidPx", 0),
        LESignedLongField("OfferPx", 0),
        LESignedLongField("BidSize", 0),
        LESignedLongField("OfferSize", 0),
        LEShortField("NumberOfBuyOrders", 0),
        LEShortField("NumberOfSellOrders", 0),
        StrFixedLenField("Pad4", "0000", 4),
    ]


    def post_build(self, p, pay):
        # p += pay  # if you also want the payload to be taken into account
        if True:
            tmp_len = len(p) # edit as you want
            # p = p[:2] + struct.pack("<I", tmp_len) + p[4:]  # Adds length as short on bytes 3-4
            p = struct.pack("<H", tmp_len) + p[2:]
        return p + pay # edit if previous is changed
	
class TradeReport(Packet):
    name = 'TradeReport'
	# sizes = (56, 56)

    fields_desc = [
        PacketField("MessageHeader", None, MessageHeaderComp),
        LESignedLongField("SecurityID", 0),
        LELongField("TransactTime", 0),
        LESignedLongField("LastQty", 0),
        LESignedLongField("LastPx", 0),
        LEIntField("TrdMatchID", 0),
        ByteField("MatchType", 0),
        ByteField("MatchSubType", 0),
        ByteField("AlgorithmicTradeIndicator", 0),
        StrFixedLenField("Pad1", "0", 1),
        LEShortField("TradeCondition", 0),
        StrFixedLenField("Pad6", "000000", 6),
    ]


    def post_build(self, p, pay):
        # p += pay  # if you also want the payload to be taken into account
        if True:
            tmp_len = len(p) # edit as you want
            # p = p[:2] + struct.pack("<I", tmp_len) + p[4:]  # Adds length as short on bytes 3-4
            p = struct.pack("<H", tmp_len) + p[2:]
        return p + pay # edit if previous is changed
	
class TradeReversal(Packet):
    name = 'TradeReversal'
	# sizes = (64, 424)

    fields_desc = [
        PacketField("MessageHeader", None, MessageHeaderComp),
        LESignedLongField("SecurityID", 0),
        LELongField("TransactTime", 0),
        LESignedLongField("LastQty", 0),
        LESignedLongField("LastPx", 0),
        LELongField("TrdRegTSExecutionTime", 0),
        LEIntField("TrdMatchID", 0),
        LEShortField("TradeCondition", 0),
        StrFixedLenField("Pad2", "00", 2),
        ByteField("NoMDEntries", 0),
        StrFixedLenField("Pad7", "0000000", 7),
        PacketListField("MDTradeEntryGrp", None, MDTradeEntryGrpComp),
    ]


    def post_build(self, p, pay):
        # p += pay  # if you also want the payload to be taken into account
        if True:
            tmp_len = len(p) # edit as you want
            # p = p[:2] + struct.pack("<I", tmp_len) + p[4:]  # Adds length as short on bytes 3-4
            p = struct.pack("<H", tmp_len) + p[2:]
        return p + pay # edit if previous is changed
	
bind_layers(UDP, PacketHeader, sport=65333, dport=65333)
