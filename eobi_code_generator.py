import sys
import eobi_preprocessor_v2
import itertools
import re
import xml.etree.ElementTree as ET

def gen_header(o=sys.stdout):
	print('''# auto-generated by Georg Sauthoff's eti2py.py
#
# SPDX-FileCopyrightText: Â© 2021 Georg Sauthoff <mail@gms.tf>
# SPDX-License-Identifier: BSL-1.0

import struct
from dataclasses import dataclass, field, is_dataclass
from enum import IntEnum

def rstrip_dc(x):
    for k, v in x.__dict__.items():
        if type(v) is bytes:
            x.__setattr__(k, x.__getattribute__(k).rstrip(b'\\0'))
        elif is_dataclass(v):
            rstrip_dc(v)

def enumerize(i, klasse):
    try:
        return klasse(i)
    except ValueError:
        return i
''', file=o)


def gen_version(xml, o=sys.stdout):
    rt = xml.getroot()
    version = rt.get('version')
    sub_version = rt.get('subVersion')
    build = rt.get('buildNumber')
    print(f"version = '{version}'", file=o)
    print(f"sub_version = '{sub_version}'", file=o)
    print(f"build = '{build}'\n", file=o)

# dt: data types dict
# ts: templates dict: numeric id -> message name
def gen_enums(dt, ts, o=sys.stdout):
	# populate no value
    def pp_nv(e, vs): # e: all the attributes of the datatype vs: valid value obj associated with this e
        nv = e.get('noValue') # noValue is how to represent the absence of the data
        if nv in vs: # if it's already in valid values
            return
        if nv.startswith('0x0'): # if start with 0x0 this implies the rest is also 0
            nv = '0'
        if nv: # otherwise append NO_VALUE to the enum class
            print(f'    NO_VALUE = {nv}', file=o)

	#generate template id enum
    print('class TemplateID(IntEnum):', file=o)
    for tid, name in ts:
        print(f'    {name} = {tid}', file=o)

    print('', file=o)
    for name, e in dt.items():
		# Here we only care about the cases where the data types has some valid values as
		# that is why we want to construct enum classes

		# when type of the data is int with valid value 
        if e.get('type') == 'int':
            vs = e.findall('ValidValue')
            if vs:
				# sort the valid values
                vs.sort(key=lambda x: int(x.get('value')))

                ws = [v.get('value') for v in vs] # possible values
                print(f'class {name}(IntEnum):', file=o)
                for v in vs: # v here is a xml obj
                    print(
                    	f'    {v.get("name").upper()} = {v.get("value")}', file=o)
                pp_nv(e, ws)
                print(file=o)

		# string of len 1 with valid value 
        elif e.get('rootType') == 'String' and e.get('size') == '1':
            vs = e.findall('ValidValue')
            if vs:
                vs.sort(key=lambda x: x.get('value'))
                ws = [v.get('value') for v in vs]
                print(f'class {name}(IntEnum):', file=o)
                for v in vs:
                    print(
                    	f'''    {v.get("name").upper()} = ord('{v.get("value")}')''', file=o)
                pp_nv(e, ws)
                print(file=o)

def get_sizes(st, dt):
    h = {}
	# datartpe size
    for name, e in dt.items():
        v = e.get('size', '0')
        if e.get('variableSize') is None:
            h[name] = int(v)
        else:
            h[name] = 0
	
	#structure size
    for name, e in itertools.chain((i for i in st.items() if i[1].get('type') != 'Message'), # i = (name, e)
                                   (i for i in st.items() if i[1].get('type') == 'Message')):
        s = 0 # total size
        for m in e:
            x = h.get(m.get('type'), 0) # get size using type
            if x == 0 or m.get('minCardinality') is not None:
                s = 0
                break
            s += x
        h[name] = s
    return h


def get_max_sizes(st, dt):
    h = {}
    for name, e in dt.items():
        v = e.get('size', '0')
        h[name] = int(v)
    for name, e in itertools.chain((i for i in st.items() if i[1].get('type') != 'Message'),
                                   (i for i in st.items() if i[1].get('type') == 'Message')):
        s = 0
        for m in e:
            x = h.get(m.get('type'), 0)
            s += x * int(m.get('cardinality'))
        h[name] = s
    return h


def get_min_sizes(st, dt):
    h = {}
    for name, e in dt.items():
        v = e.get('size', '0')
        if e.get('variableSize') is None:
            h[name] = int(v)
        else:
            h[name] = 0
    for name, e in itertools.chain((i for i in st.items() if i[1].get('type') != 'Message'),
                                   (i for i in st.items() if i[1].get('type') == 'Message')):
        s = 0
        for m in e:
            x = h.get(m.get('type'), 0)
            s += x * int(m.get('minCardinality', '1'))
        h[name] = s
    return h



# st: structures
# dt: data types
# us: usages
# rule of thumb: when generating informations, generate for those that is of message type first, since
# messages are assembled using non message type
def gen_blocks(version, st, dt, us, o=sys.stdout):
    sizes = get_sizes(st, dt)
    min_sizes = get_min_sizes(st, dt)
    max_sizes = get_max_sizes(st, dt)
    for name, e in st.items():
        if e.get('type') == 'Message':
            continue
        gen_block(name, e, st, dt, us, sizes, min_sizes, max_sizes, version, o)
    for name, e in st.items():
        if e.get('type') != 'Message':
            continue
        gen_block(name, e, st, dt, us, sizes, min_sizes, max_sizes, version, o)



def is_padding(t):
    pad_re = re.compile('Pad[1-9]')
    if t is not None:
        return t.get('rootType') == 'String' and pad_re.match(t.get('name'))
    return False


def is_int(t):
    if t is not None:
        r = t.get('rootType')
        return r in ('int', 'floatDecimal') or (r == 'String' and t.get('size') == '1')
    return False


def is_unsigned(t):
    v = t.get('minValue')
    return v is not None and not v.startswith('-')

def pp_int_type(t):
    if not is_int(t):
        return None
    s = 'i'
    if is_unsigned(t):
        s = 'u'
    n = int(t.get('size'))
    s += str(n)
    return s


def is_counter(t):
    return t.get('type') == 'Counter'

def is_enum(t):
    if t is not None:
        r = t.get('rootType')
        if r == 'int' or (r == 'String' and t.get('size') == '1'):
            return t.find('ValidValue') is not None
    return False

# name: name of the struct
# e: xml obj of the struct
# st: all the structures
# dt: all the datatypes
# us: usages, infor from Application messagesHi
# size, min_sizes, max_sizes: size information about the struct
# version: version info
def gen_fields(e, st, dt, us, sizes, min_sizes, version, o=sys.stdout, comment=False, off=0, fname=None):
    for m in e: # m is member of the message
        if comment:
            print('    #', end='')
        atts = []
        t = dt.get(m.get('type'))
        if is_padding(t):
            print(f'    # PADDING={t.get("size")}', end='', file=o)
        elif is_int(t):
            atts.append(pp_int_type(t))
            def_str = '0'
            nv = t.get('noValue')
            if nv:
                def_str = nv
            if def_str == '0x00' or is_counter(t):
                def_str = '0'
            elif def_str.startswith('0x80'):
                def_str = str(2**(8*int(t.get('size')) - 1) * -1)
            if is_enum(t):
                atts.append(f'enum:{t.get("name")}')
                def_str = f"{t.get('name')}({def_str})"
            print(f'    {m.get("name")}: int = {def_str}', end='', file=o)
            scale = t.get('precision')
            if scale:
                atts.append(f'scale:{scale}')
        elif is_fixed_string(t) or is_var_string(t):
            if is_var_string(t):
                atts.append(f'length:{m.get("counter")}')
            # when packing, struct.pack right-pads missing bytes with zero bytes
            def_str = "b''"
            if m.get('type') == 'DefaultCstmApplVerID':
                def_str = f"b'{version[0]}'"
            if m.get('type') == 'DefaultCstmApplVerSubID':
                def_str = f"b'{version[1]}'"
            print(f"""    {m.get("name")}: bytes = {def_str}""",
                  end='', file=o)
        else:
            if m.get('type') in ('MessageHeaderInComp', 'MessageHeaderOutComp', 'MessageHeaderComp'):
                l = sizes[e.get('name')]
                if l == 0:
                    l = min_sizes[e.get('name')]
                def_str = f'field(default_factory=lambda : {m.get("type")}({l}, {e.get("numericID")}))'
            else:
                def_str = f'field(default_factory={m.get("type")})'
            if m.get('minCardinality') is None:
                print(
                    f'    {m.get("name")}: {m.get("type")} = {def_str}', end='', file=o)
            else:
                print(
                    f'    {m.get("name")}: [{m.get("type")}] = field(default_factory=list)', end='', file=o)

        # atts.append(f'fmt:{type_to_fmt(t)}')
        atts.append(f'size:{sizes[m.get("type")]}')
        if off is not None:
            atts.append(f'off:{off}')
        u = us.get((fname if fname else e.get('name'), m.get('name')), None)
        if not is_padding(t) and u and u != 'mandatory':
            atts.append(u.upper())
        print(f' # {", ".join(atts)}', file=o)

        s = st.get(m.get('type'))
        if s:
            gen_fields(s, st, dt, us, sizes, min_sizes, version, o,
                       comment=True, off=off, fname=f"{e.get('name')}.{m.get('name')}")

        if off is not None:
            l = sizes[m.get('type')]
            if l == 0:
                off = None
            else:
                off += l


def is_elementary(t):
    return t is not None and t.get('counter') is None

def group_members(e, dt):
    xs = []
    ms = []
    for m in e:
        t = dt.get(m.get('type'))
        if is_elementary(t):
            ms.append(m)
        else:
            if ms:
                xs.append(ms)
                ms = []
            xs.append([m])
    if ms:
        xs.append(ms)
    return xs

# name: name of the struct
# e: xml obj of the struct
# st: all the structures
# dt: all the datatypes
# us: usages, infor from Application messagesHi 
# size, min_sizes, max_sizes: size information about the struct
# version: version info
def gen_block(name, e, st, dt, us, sizes, min_sizes, max_sizes, version, o=sys.stdout):
    print(f'@dataclass\nclass {name}:')
    print(f'    sizes = ({min_sizes[name]}, {max_sizes[name]})\n', file=o)
    gen_fields(e, st, dt, us, sizes, min_sizes, version, o)

    ms = group_members(e, dt)

    print(f'\n    def update_length(self):', file=o)
    if sizes[name] == 0 and e.get('type') == 'Message':
        header = get_header_name(e)
        ls = []
        seen_var_string = False
        for xs in ms:
            t = dt.get(xs[0].get('type'))
            l = sum(sizes[m.get("type")] for m in xs)
            if is_var_string(t):
                ls.append(f'self.{xs[0].get("counter")}')
                seen_var_string = True
            elif xs[0].get('minCardinality') is not None:
                ls.append(f'self.{xs[0].get("counter")} * {l}')
            else:
                ls.append(str(l))
        if seen_var_string:
            print(
            	f'        self.{header}.BodyLen = ({" + ".join(ls)} + 7) // 8 * 8', file=o)
        else:
            print(f'        self.{header}.BodyLen = {" + ".join(ls)}', file=o)
    else:
        print(f'        pass', file=o)
    print(file=o)

    fs = [("'<" + ''.join(type_to_fmt(dt.get(a.get('type')))
           for a in xs) + "'") for xs in ms]
    print(f'    fmt = ( {", ".join(fs)}, )', file=o)

    print(f'    _struct = [ {", ".join("None" for _ in ms)} ]', file=o)
    print('''
    @classmethod
    def st(cls, i):
        if cls._struct[i] is None:
            cls._struct[i] = struct.Struct(cls.fmt[i])
        return cls._struct[i]''', file=o)

    gen_pack(name, e, st, dt, sizes, min_sizes, max_sizes, ms, o)
    gen_unpack(name, e, st, dt, sizes, min_sizes, max_sizes, ms, o)

    gen_setter(o)

    print('    def rstrip(self):\n        rstrip_dc(self)', file=o)

    print('', file=o)




def main():
	xml = ET.parse(eobi_preprocessor_v2.PATH_TO_ETI_SPEC)
	[dt, st, ts, us, mf] = eobi_preprocessor_v2.main()
	version = (xml.getroot().get('version'), xml.getroot().get('subVersion'))
	gen_header()
	gen_version(xml)
	gen_enums(dt, ts)

	gen_blocks(version, st, dt, us)

	# gen_unpack_factory(ts, dt)

	# gen_message_flows(mf)

if __name__ == '__main__':
	main()
